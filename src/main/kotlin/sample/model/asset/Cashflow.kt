package sample.model.asset

import jakarta.validation.constraints.NotNull
import java.math.BigDecimal
import java.time.LocalDate
import java.time.LocalDateTime
import org.springframework.data.annotation.Id
import org.springframework.data.domain.Sort
import org.springframework.data.relational.core.mapping.Table
import sample.ActionStatusType
import sample.context.DomainEntity
import sample.context.DomainHelper
import sample.context.Dto
import sample.context.orm.OrmRepository
import sample.model.DomainErrorKeys
import sample.model.constraints.AccountId
import sample.model.constraints.Amount
import sample.model.constraints.Category
import sample.model.constraints.Currency
import sample.model.constraints.ISODate
import sample.model.constraints.ISODateEmpty
import sample.model.constraints.ISODateTime
import sample.util.TimePoint
import sample.util.Validator

/**
 * Account activity cashflow. The cashflow is account activity information of the decision state
 * generated by a cashflow action such as the transfer (without the request cancellation). low: The
 * minimum columns with this sample
 */
@Table("CASHFLOW")
data class Cashflow(
        @Id val id: String,
        @AccountId val accountId: String,
        @Currency val currency: String,
        @Amount val amount: BigDecimal,
        @NotNull val cashflowType: CashflowType,
        @Category val remark: String,
        @ISODate val eventDay: LocalDate,
        @ISODateTime val eventDate: LocalDateTime,
        @ISODate val valueDay: LocalDate,
        @NotNull val statusType: ActionStatusType,
        @AccountId val updateActor: String,
        @ISODateTime val updateDate: LocalDateTime
) : DomainEntity {

        override fun getId(): Any = id

        /** Make cashflow processed and reflect it to the balance. */
        fun realize(rep: OrmRepository): Cashflow {
                val now = rep.dh().time().tp()
                Validator.validate { v ->
                        v.verify(canRealize(rep), AssetErrorKeys.CF_REALIZE_DAY)
                        v.verify(statusType.isUnprocessing(), DomainErrorKeys.STATUS_PROCESSING)
                }

                val updatedCashflow =
                        rep.update(
                                this.copy(
                                        statusType = ActionStatusType.PROCESSED,
                                        updateActor = rep.dh().actor().id,
                                        updateDate = now.date
                                )
                        )
                CashBalance.getOrNew(rep, accountId, currency).add(rep, amount)
                return updatedCashflow
        }

        /** Mark error status. low: Actually, Take error reasons in an argument and maintain it. */
        fun error(rep: OrmRepository): Cashflow {
                Validator.validate { v ->
                        v.verify(statusType.isUnprocessed(), DomainErrorKeys.STATUS_PROCESSING)
                }

                return rep.update(
                        this.copy(
                                statusType = ActionStatusType.ERROR,
                                updateActor = rep.dh().actor().id,
                                updateDate = rep.dh().time().date()
                        )
                )
        }

        fun canRealize(rep: OrmRepository): Boolean = rep.dh().time().tp().afterEqualsDay(valueDay)

        /** Cashflow types. */
        enum class CashflowType {
                CASH_IN,
                CASH_OUT,
                CASH_TRANSFER_IN,
                CASH_TRANSFER_OUT
        }

        data class RegCashflow(
                @AccountId val accountId: String,
                @Currency val currency: String,
                @Amount val amount: BigDecimal,
                @NotNull val cashflowType: CashflowType,
                @Category val remark: String,
                @ISODateEmpty val eventDay: LocalDate?,
                @ISODate val valueDay: LocalDate
        ) : Dto {

                fun create(dh: DomainHelper): Cashflow {
                        val now = dh.time().tp()
                        val id = dh.uid().generate(Cashflow::class.java.simpleName)
                        val eventDate = eventDay?.let { TimePoint(it, now.date) } ?: now
                        val updActor = dh.actor().id
                        return Cashflow(
                                id = id,
                                accountId = accountId,
                                currency = currency,
                                amount = amount,
                                cashflowType = cashflowType,
                                remark = remark,
                                eventDay = eventDate.day,
                                eventDate = eventDate.date,
                                valueDay = valueDay,
                                statusType = ActionStatusType.UNPROCESSED,
                                updateActor = updActor,
                                updateDate = now.date
                        )
                }
        }

        companion object {
                fun load(rep: OrmRepository, id: String): Cashflow =
                        rep.load(Cashflow::class.java, id)

                fun findUnrealize(
                        rep: OrmRepository,
                        accountId: String,
                        currency: String,
                        valueDay: LocalDate
                ): List<Cashflow> {
                        val sort = Sort.by(Sort.Direction.ASC, "id")
                        return rep.tmpl()
                                .find(
                                        Cashflow::class.java,
                                        { criteria ->
                                                criteria.and("accountId")
                                                        .`is`(accountId)
                                                        .and("currency")
                                                        .`is`(currency)
                                                        .and("valueDay")
                                                        .lessThanOrEquals(valueDay)
                                                        .and("statusType")
                                                        .`in`(ActionStatusType.UNPROCESSED_TYPES)
                                        },
                                        sort
                                )
                }

                fun findDoRealize(rep: OrmRepository, valueDay: LocalDate): List<Cashflow> {
                        val sort = Sort.by(Sort.Direction.ASC, "id")
                        return rep.tmpl()
                                .find(
                                        Cashflow::class.java,
                                        { criteria ->
                                                criteria.and("valueDay")
                                                        .`is`(valueDay)
                                                        .and("statusType")
                                                        .`in`(ActionStatusType.UNPROCESSED_TYPES)
                                        },
                                        sort
                                )
                }

                /** Register cashflow. <p> Reached a value day, just reflect it to the balance. */
                fun register(rep: OrmRepository, p: RegCashflow): Cashflow {
                        val now = rep.dh().time().tp()
                        Validator.validate { v ->
                                v.checkField(
                                        now.beforeEqualsDay(p.valueDay),
                                        "valueDay",
                                        "error.Cashflow.beforeEqualsDay"
                                )
                        }
                        val cf = rep.save(p.create(rep.dh()))
                        return if (cf.canRealize(rep)) cf.realize(rep) else cf
                }
        }
}
